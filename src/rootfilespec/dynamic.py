from rootfilespec import bootstrap
from rootfilespec.bootstrap.TStreamerInfo import (
    ClassDef,
    TStreamerInfo,
)
from rootfilespec.dispatch import DICTIONARY, normalize

# TODO: make a generated/__init__.py file out of this
PREAMBLE = """# Generated by streamerinfo_to_classes

from typing import Annotated, Optional

import numpy as np

from rootfilespec.bootstrap import *
from rootfilespec.container import (
    BasicArray,
    FixedSizeArray,
    StdVector,
)
from rootfilespec.dispatch import DICTIONARY
from rootfilespec.serializable import serializable
from rootfilespec.structutil import Fmt

"""

BOOTSTRAP_TYPES: set[str] = set(bootstrap.__all__)


def streamerinfo_to_classes(streamerinfo: bootstrap.TList) -> str:
    lines: list[str] = list(PREAMBLE.split("\n"))

    classes: dict[str, ClassDef] = {}
    declared: set[str] = set(BOOTSTRAP_TYPES)

    for item in streamerinfo.items:
        if not isinstance(item, TStreamerInfo):
            continue
        clsname = normalize(item.fName.fString)
        if clsname in DICTIONARY:
            lines.append(f"# Class {clsname} already in dictionary, skipping\n")
            declared.add(clsname)
            continue
        classdef = item.class_definition()
        classes[classdef.name] = classdef

    # Write out in dependency order
    def write(classdef: ClassDef):
        for dep in classdef.dependencies:
            depdef = classes.pop(dep, None)
            if depdef is not None:
                write(depdef)
            elif dep not in declared:
                msg = f"Class {classdef.name} depends on {dep}, which is not declared"
                raise ValueError(msg)
        lines.append(classdef.code)
        declared.add(classdef.name)

    while classes:
        _, classdef = classes.popitem()
        write(classdef)

    return "\n".join(lines)
